<html>

<head>
    <meta charset="UTF-8"
        name="viewport"
        content="width=device-width, user-scalable=no">
    <script language="javascript"
        type="text/javascript"
        src="./image_config.js"></script>
    <script language="javascript"
        src="lib/vector.js"></script>
    <script language="javascript"
        src="lib/drawbase.js"></script>
    <script language="javascript"
        src="lib/PhysicsObject.js"></script>
    <script language="javascript"
        src="lib/DomObject.js"></script>
    <script language="javascript"
        src="lib/Character.js"></script>
    <script language="javascript"
        src="lib/collisioncontainer.js"></script>
    <script language="javascript"
        src="lib/eventemitter.js"></script>
    <script language="javascript"
        src="lib/PlayerImages.js"></script>
    <title>Artem's Fighting Game</title>
    <link rel="stylesheet"
        href="global_styles.css">
</head>

<body>
    <div id="debugdiv"
        style="position: absolute; left: 0; top: 0; color: white; z-index: 999999999;"></div>
    <div id="MAIN_WRAPPER">
        <div id="MAIN_SCREEN">
            <!-- Everything for the game should be here -->
            <p style="position: absolute; font-size: 1em; top: 70px; left: 40px; color: deepskyblue; text-shadow: black 0 0 2px; font-weight: bolder"
                id="playerhp"></p>
            <p style="position: absolute;  font-size: 1em; top: 55px; left: 520px; color: deepskyblue; text-shadow: black 0 0 2px; font-weight: bolder"
                id="enemyhp"></p>
            <button id="btn_top_left"
                class="controlBtn"><span class="powerText innerText">Power</span> </button>
            <button id="btn_top_mid"
                class="controlBtn"><span class="innerText">Jump &nbsp; ← left</span></button>
            <button id="btn_top_right"
                class="controlBtn"><span class="innerText">Jump &nbsp; right →</span></button>
            <button id="btn_bot_left"
                class="controlBtn"><span class="shieldText innerText">Block</span></button>
            <button id="btn_bot_mid"
                class="controlBtn"><span class="shootText innerText">shoot &nbsp; ← left</span></button>
            <button id="btn_bot_right"
                class="controlBtn"><span class="shootText innerText">shoot
                    right →</span></button>
            <button id="play_pause"
                class="controlBtn"><span id="play_PauseText"
                    class="innerText">paused</span></button>
            <div id="image_blocker"
                style="position: absolute;top: 0; left: 0; z-index: 9; background-color:#26445e">
            </div>
        </div>
    </div>
    <style>
        body {
            background-color: black;
        }

        .controlBtn {
            position: absolute;
            border-top: #a1a19e solid 0.3vw;
            border-left: #424242 solid 0.3vw;
            border-right: #8d8988 solid 0.3vw;
            border-bottom: #232423 solid 0.3vw;
            border-radius: 0.1vw;
            z-index: 100000;
            left: 0%;
            bottom: 10%;
            height: 10%;
            width: 7%;
            background-image: linear-gradient(to bottom right, #eee 0%, #e1e1e1 10%, #ddd 14%, #fff 30%, #ddd 60%, #eee 85%, #ccc 100%);
            font-weight: bolder;
            padding: 0;
        }

        .controlBtn:active {
            border: solid blue 0.3vw;
        }

        .innerText {
            background-color: blue;
            color: transparent;
            text-shadow: rgba(255, 255, 255, 0.5) 2px 2px 2px;
            margin: 0;
            position: relative;
            background-clip: text;
            -moz-background-clip: text;
            -webkit-background-clip: text;
        }

        #play_pause {
            height: 5%;
            top: 0;
            left: 0;
            position: absolute;
        }

        .powerText {
            background-color: orange;
        }

        .shootText {
            background-color: red;
        }

        .shieldText {
            background-color: limegreen;
        }

        #btn_bot_mid {
            left: 7%;
            bottom: 0;
        }

        #btn_top_left {
            border-radius: 2.5vw 0.3vw 0.3vw 0.3vw;
        }

        #btn_top_mid {
            left: 7%;
        }

        #btn_top_left:active {
            border: solid orange 0.3vw;
        }

        #btn_top_right {
            border-radius: 0.3vw 2.5vw 0.3vw 0.3vw;
            left: 14%;
        }

        #btn_bot_left {
            border-radius: 0.3vw 0.3vw 0.3vw 2.5vw;
            bottom: 0;
        }

        #btn_bot_left:active {
            border: solid limegreen 0.3vw;
        }

        #btn_bot_right {
            border-radius: 0.3vw 0.3vw 2.5vw 0.3vw;
            bottom: 0;
            left: 14%;
        }

        #btn_bot_right:active {
            border: solid red 0.3vw;
        }

        #btn_bot_mid:active {
            border: solid red 0.3vw;
        }

        #play_pause:active {
            border-top: #a1a19e solid 0.3vw;
            border-left: #424242 solid 0.3vw;
            border-right: #8d8988 solid 0.3vw;
            border-bottom: #232423 solid 0.3vw;
        }

    </style>
    <script>
        //=============  DEBUG WITHOUT CONSOLE STUFF =====================
        // if (typeof console !== 'undefined') {
        //     if (typeof console.log !== 'undefined') {
        //         console.olog = console.log;
        //     } else {
        //         console.olog = function () {};
        //     }
        //     console.log = function (message) {
        //         console.olog(message);
        //         id('debugdiv').append(`\n` + message)
        //     }
        //     console.error = console.exception = console.debug = console.info = console.log;
        // }
        // window.addEventListener('error', e => {
        //     id('debugdiv').append(`\n` + e.message)
        // });
        // id('debugdiv').addEventListener('click', () => {
        //     id('debugdiv').innerText = ''
        // })
        //=============  END DEBUG WITHOUT CONSOLE STUFF ==================


        let HARDMODE = false;
        let IMAGE_PATH = './images/';
        let BACKGROUND_CONFIG = IMAGE_CONFIG.backgrounds
        let MONSTER_CONFIG = IMAGE_CONFIG.monsters
        let NUM_OF_MONSTERS = MONSTER_CONFIG.num;

        let DEFAULT_BG_ZOOM_LEVEL = 5;

        let ZOOM_LEVEL = 2;

        let valid_colors = ['red', 'yellow', 'blue', 'teal', 'lightblue', 'purple', 'pink', 'orange', 'white', 'black']


        let scaleMultiplier = 1;


        let PLAYER_SPRITE_WIDTH = width / 6.4;

        class MonsterController extends Array {
            constructor(...args) {
                super(...args)
                this.maxIndex = 5;
            }
            killAll() {
                for (let i = 0; i < this.maxIndex; i++) {
                    this[i].character.kill();
                }
            }
            get isAllDead() {
                return this.filter(x => !x.character.dead).length === 0
            }
        }


        function setupBackground() {
            return new Promise(resolve => {
                scaleMultiplier = width / 960;
                Array.from(document.getElementsByClassName('controlBtn')).forEach(x => {
                    x.style.fontSize = width / 60 + 'px';
                })
                let background = 'background' + (getRandom(BACKGROUND_CONFIG.num)).toString() + '.jpg';
                DOMObjectGlobals.body.style.backgroundColor = 'grey';
                DOMObjectGlobals.body.style.backgroundImage = 'url(' + IMAGE_PATH + BACKGROUND_CONFIG.path +
                    background.toString() + ')';
                DOMObjectGlobals.body.style.backgroundSize = width + 'px auto';
                DOMObjectGlobals.body.style.backgroundRepeat = 'no-repeat';
                id('image_blocker').style.backgroundColor = 'grey';
                id('image_blocker').style.backgroundImage = 'url(' + IMAGE_PATH + BACKGROUND_CONFIG.path +
                    background.toString() + ')';
                id('image_blocker').style.backgroundSize = width + 'px auto';
                id('image_blocker').style.backgroundRepeat = 'no-repeat';
                id('image_blocker').style.width = width / 12 + 'px'
                id('image_blocker').style.height = width / 12 + 'px';
                VECTORS.gravity.y *= scaleMultiplier;
                zoomBackground(DEFAULT_BG_ZOOM_LEVEL)
                requestAnimationFrame(() => {
                    DOMObjectGlobals.body.style.transition = '1s'
                    id('image_blocker').style.transition = '1s'
                })
                resolve()
            })
        }

        function zoomBackground(level) {
            DOMObjectGlobals.body.style.backgroundSize = r(width * (1 + (level / 10))) + 'px auto';
            DOMObjectGlobals.body.style.backgroundPosition = r(width * (level / -20)) + 'px ' + r(height * (level / -12)) + 'px';
            id('image_blocker').style.backgroundSize = r(width * (1 + (level / 10))) + 'px auto';
            id('image_blocker').style.backgroundPosition = r(width * (level / -20)) + 'px ' + r(height * (level / -12)) + 'px';
        }

        function zoomPlayer(level) {
            player.sprite.shape.style.transition = '1s';
            player.sprite.shape.style.transitionProperty = 'transform';
            player.scale = (1 + level / 10)
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    player.sprite.shape.style.transform.match(/scale\(-?\d+\.?\d*\)/g) !== null ? (player.sprite.shape.style.transform = player.sprite.shape.style.transform.replace(/scale\(-?\d+\.?\d*\)/g, 'scale(' + (1 +
                        level / 10) + ')')) : (player
                        .sprite.shape
                        .style
                        .transform += 'scale(' + (1 + level / 10) + ')');
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            player.sprite.shape.style.transition = '';
                            player.sprite.shape.style.transitionProperty = '';
                        })
                    })
                })
            })
        }

        function zoomMonsters(level) {
            monsters.forEach(monster => {
                monster.character.sprite.shape.style.transition = '1s';
                monster.character.sprite.shape.style.transitionProperty = 'transform';
                monster.scale = (1 + level / 10)
                let xPos = monster.character.x;
                let xOffset = xPos >= width / 2 ? xPos / width - 0.5 : 0.5 - xPos / width;
                let xDiff = (0.5 - xOffset) / 2 * (1 + level / -10);
                let newX = xPos
                // >= width / 2 ? (0.5 + xOffset + xDiff) * width : (0.5 - xOffset - xDiff) * width
                // monster.character.doMoveTo(new Vector(newX, monster.character
                //     .y));
                console.log(newX)
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        monster.character.sprite.shape.style.transform.match(/scale\(-?\d+\.?\d*\)/g) !== null ? (monster.character.sprite.shape.style.transform = monster.character.sprite.shape.style.transform
                            .replace(/scale\(-?\d+\.?\d*\)/g,
                                'scale(' + (1 +
                                    level / 10) + ')')) : (monster.character
                            .sprite.shape
                            .style
                            .transform += 'scale(' + (1 + level / 10) + ')');
                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                monster.character.sprite.shape.style.transition = '';
                                monster.character.sprite.shape.style.transitionProperty = '';
                            })
                        })
                    })
                })
            })
        }
        let ZOOM_SCALE = 1;

        function zoomEverything(level) {
            ZOOM_SCALE = 1 + level / 10;
            zoomBackground(Math.max(0, DEFAULT_BG_ZOOM_LEVEL + level))
            zoomPlayer(level)
            zoomMonsters(level)
        }

        function create_monster(num) {
            let mons_num = num || getRandom(NUM_OF_MONSTERS + 2);
            let mons_name = '';
            let monster_powr_name = powers[Math.random() * powers.length | 0];
            if (mons_num > NUM_OF_MONSTERS) {
                let exception = mons_num - NUM_OF_MONSTERS;
                if (exception == 2) {
                    mons_name = 'thanos';
                    monster_powr_name = 'blackenergy'
                } else if (exception == 1) {
                    mons_name = 'venom';
                    monster_powr_name = 'blackenergy'
                }
            } else {
                mons_name = 'monster' + (Math.random() * NUM_OF_MONSTERS | 0);
            }
            if (mons_name.endsWith('15')) {
                monster_powr_name = 'spaghetti'
            }
            return {
                num: mons_num,
                name: mons_name,
                power: monster_powr_name
            };
        }

        let player_char;
        let monster_char;

        function choose_your_fighter() {
            let num_of_choices = 4;
            let chosen_nums = [];
            for (let i = 0; i < num_of_choices; i++) {
                let num = getRandom(characters.length);
                while (chosen_nums.includes(num)) {
                    num = getRandom(characters.length);
                }
                chosen_nums.push(num);
            }
            let screenw = width / 1.5;
            let screenh = width / 5;
            let screenx = width / 2 - screenw / 2;
            let screeny = height / 2 - screenh / 2;
            let screen = new Rectangle(screenx, screeny, screenw, screenh);
            let screenstyle = {
                backgroundColor: 'grey',
                borderRadius: r(width / 96) + 'px',
                border: 'blue solid ' + r(width / 210) + 'px'
            };
            Object.assign(screen.shape.style, screenstyle);
            let crop = new Rectangle(screenx + r(width / 192), screeny + screenh / 3 - r(width / 192), screenw - r(
                width / 192), screenh / 3);
            crop.shape.style.overflow = 'hidden';
            crop.shape.style.backgroundColor = 'yellow';
            crop.shape.style.border = 'blue solid ' + r(width / 320) + 'px';

            let images = [];
            let lines = [];
            let text = new P('Choose Your Fighter', screenw / 2, screenh / 10, r(width / 30)).fromCenter();
            let names = [];
            screen.attach(text)

            function start_the_game(num) {
                crop.remove();
                lines.forEach(line => {
                    line.remove();
                });
                names.forEach(name => {
                    name.remove();
                });
                text.remove();
                screen.remove();
                player_char = create_player(num);
                monster_char = create_monster();
                setup();
            }

            chosen_nums.forEach((num, i) => {
                let img = new Img(IMAGE_PATH + characters[num] + '.png', ((screenw / chosen_nums.length)) * i +
                    10, 0, (screenw / chosen_nums.length) - width / 50);
                crop.attach(img);
                if (i !== 0) {
                    let line = Line.fromPoints(screenx + r(width / 192) + (screenw / chosen_nums.length) * i,
                        screeny +
                        screenh / 1.5 - r(width / 192), screenx + r(width / 192) + (screenw / chosen_nums
                            .length) * i + r(width / 40), screeny +
                        screenh / 3 - r(width / 192), r(width / 300));
                    line.shape.style.backgroundColor = 'blue';
                    lines.push(line);
                }
                img.shape.addEventListener('click', () => {
                    start_the_game(num);
                });
                let actual_name = characters[num].split('_').map(x => x[0].toUpperCase() + x.slice(1, x.length))
                    .join(' ');
                if (!isNaN(actual_name[actual_name.length - 1])) {
                    actual_name = actual_name.slice(0, actual_name.length - 1)
                }
                let name = new P(actual_name, screenx + (screenw / chosen_nums.length) * (i + .1) + 10, 5 +
                    screeny + screenh / 1.5, width / 40);
                if (name.width + width / 48 > screenw / chosen_nums.length) {
                    name.string = actual_name.slice(0, 7) + '..'
                }
                names.push(name);
                images.push(img);
            });

            return chosen_nums;
        }


        let
            LOADED_IMAGES; // = new ImageLoader('./images/', ['fire', 'shield', monster_char.power + 'ball', player_char.power + 'ball']);
        let player; // = new Character(25, 100, player_char.name);
        let projectiles = [];
        let playerHP = {};
        let leftMonsterHP = {} //maybe can be combined with the other one
        let monsters = new MonsterController();

        function createHPBar(image, x, y, isPlayer, isLeftSide) {
            let hpBar = new LoadingBar(x, y, width / 3, width / 35, 0, 100, 100);
            let circle = new Circle(hpBar.x + (isLeftSide ? 0 : hpBar.width), hpBar.y + width / 26, width / 26);
            circle.color = 'red';
            circle.border = 'solid blue ' + r(width / 300) + 'px';
            circle.zIndex = 10;
            hpBar.zIndex = 9;
            if (isLeftSide) {
                hpBar.set('borderRadius', '0px 0px 80px 0px/0 0 40px 0');
            } else {
                hpBar.set('borderRadius', '0 80px 0 0/0 40px 0 0');
                hpBar.angle = 180;
            }
            hpBar.set('overflow', 'hidden')
            let img = new Img(image.cloneNode(), 0, 0, width / 12).onLoad(x => {
                if (!isLeftSide) img.set('transform', 'scaleX(-1)');
                img.y += 10
                circle.attach(img);
            });
            if (isPlayer) circle.color = 'white';
            circle.set('overflow', 'hidden')
            hpBar.circle = circle;
            return hpBar;
        }

        function setup() {
            //loading bar
            let monster = {};
            let monsterHP = {}
            let blur = new Rectangle(0, 0, width, height);
            blur.set('zIndex', '99000');
            blur.set('backgroundColor', 'rgba(200,200,200,0.7)');
            let loadingBar = new LoadingBar(width / 2 - width / 4, height / 2, width / 2, width / 17, 0, 100, 0);
            loadingBar.set('zIndex', '1001');
            let loadingText = new P('Loading...', width / 2, height / 2 + width / 34, width / 30).fromCenter();
            loadingText.set('zIndex', '1001');

            function clearLoad() {
                blur.remove();
                loadingBar.remove();
                loadingText.remove();
            }

            LOADED_IMAGES = new ImageLoader(IMAGE_PATH + 'projectiles/', ['fire', 'shield', monster_char.power +
                '_projectile', player_char.power + '_projectile'
            ]);
            LOADED_IMAGES.add(['skull', 'skull_open', 'warning'], IMAGE_PATH);
            player = new Character(width * 0.1, height / 4, player_char.name);
            monster = new Character(width * 0.9, height / 4, monster_char.name);



            player.powerType = player_char.power;
            player.hasNoSkyBox = true;
            loadingBar.value += 10;
            let player_sprite = new Img(IMAGE_PATH + player_char.name + ".png", 0, 0, width / 6.4).fromCenter()
                .usingNewTransform().onLoad(() => {
                    player.addSprite(player_sprite);
                    player_sprite.zIndex = 5000
                    player.jumpMult = 20 * width / 960;
                    player.addDeathImage(LOADED_IMAGES['fire'].cloneNode());
                    let shield_name = 'shield_' + player_char.color;
                    LOADED_IMAGES.add([shield_name], IMAGE_PATH + '/projectiles/');
                    player.addShieldImage(LOADED_IMAGES[shield_name].cloneNode())
                    player.maxbounds.y = (height * 1.1) / 2 + player.height / 2;
                    player.sprite.shape.addEventListener('click', () => {
                        player.turnAround()
                    })
                    monster.projectileOffsetHeight = -player.height / 3;
                    loadingBar.value += 30;
                    playerHP = createHPBar(player.sprite.shape, width * 0.1, height * 0.01, true, true)
                });

            player.addForce(VECTORS.gravity);

            setInterval(() => {
                loadingBar.value += 1;
            }, 5)
            loadingBar.on(100, () => {
                clearLoad();
                start();
                setTimeout(() => {
                    spawnNewMonster(0, width * 0.8, true, false);
                }, 1000)
            })
        }

        let PLAYING = false;
        let secret = false; //for the hardmode double click
        let secretTO; //timeout needed for doubleclick
        let HARDMODE_HAS_BEEN_ENABLED = false;
        let SUPER_HARDMODE = false;
        id('play_pause').addEventListener('click', function () {
            PLAYING = !PLAYING;
            if (PLAYING) {
                id('play_PauseText').innerText = 'playing';
            } else {
                id('play_PauseText').innerText = 'paused';
            }
            if (secret) {
                if (monsters[0].character.dead && !currentlySpawning) {
                    let spawnOnLeftSide = !getRandom(4)
                    let offset = SUPER_HARDMODE_MODE === 'inactive' ? 0.2 : 0.1
                    spawnNewMonster(0, spawnOnLeftSide ? width * offset : width * (1 - offset), !spawnOnLeftSide, false);
                } else if (!currentlySpawning) {
                    id('play_PauseText').innerText = 'Playing';
                    PLAYING = true;
                    HARDMODE = true;

                }
            }
            secret = true;
            secretTO = setTimeout(() => {
                secret = false;
            }, 1000);
        });

        id('btn_top_right').addEventListener('click', function () {
            if (player.dead) return;
            player.jumpRight(1.2 * ZOOM_SCALE);
        });
        id('btn_top_mid').addEventListener('click', function () {
            if (player.dead) return;
            player.jumpLeft(1.2 * ZOOM_SCALE);
        });
        id('btn_bot_left').addEventListener('click', function () {
            if (player.dead) return;
            if (!player.isShielded) {
                player.shield();
                if (Math.random() * 2 < 1.5) {
                    setTimeout(() => {
                        monsterShoot();
                    }, 1500);
                }
            }
        });
        id('btn_top_left').addEventListener('click', function () {
            if (player.dead) return;
            player.powerUp(2)
            monsters.forEach(monster => {
                if (PLAYING && !monster.character.dead) {
                    let n = Math.random() * 70;
                    if (n > 5 && n < 10) {
                        if (monster.character.health > 90) {
                            monster.character.jumpUp(5);
                        }
                    } else if (n <= 4) {
                        monster.character.shield(getRandom(1, 5));
                    }
                }
            })
        });

        function playerShoot() {
            let projectile = player.shoot();
            if (projectile) {
                projectile.owner = 'player';
                projectiles.push(projectile);
                monsters.forEach(monster => {
                    if (PLAYING && !monster.character.dead) {
                        let n = Math.random() * 10;
                        if (n > 9) {
                            if (monster.character.health > 90) {
                                monster.character.jumpUp(5);
                            }
                        } else if (n > 8) {
                            monster.character.shield(getRandom(1, 5));
                        }
                    }
                })
            }
            if (player.name == 'arceus') {
                let newInfo = create_player(67);
                LOADED_IMAGES.add([newInfo.power + '_projectile'], IMAGE_PATH + '/projectiles/');
                player.powerType = newInfo.power;
            }
            if (player.name == 'steve') {
                let rand = getRandom(10)
                let newPower = 'grassblock'
                if (rand > 3 && rand < 6) {
                    newPower = 'cobblestoneblock'
                } else if (rand >= 6 && rand < 9) {
                    newPower = 'woodblock'
                } else if (rand == 9) {
                    newPower = 'diamondblock'
                }
                if (!LOADED_IMAGES[newPower + '_projectile']) {
                    LOADED_IMAGES.add([newPower + '_projectile'], IMAGE_PATH + '/projectiles/');
                }
                player.powerType = newPower;
            }
        }
        id('btn_bot_mid').addEventListener('click', function () {
            if (player.dead) return;
            player.faceLeft()
            playerShoot();
        });
        id('btn_bot_right').addEventListener('click', () => {
            if (player.dead) return;
            player.faceRight()
            playerShoot();
        });
        let currentlySpawning = false;

        function createFallingMonster(x, name, power, imagePath, index, facingLeft) {
            let monster = {}
            let monsterHP = {}
            let warning = new Img(LOADED_IMAGES.warning.cloneNode(), x, width / 12, width * ZOOM_SCALE / 5).fromCenter().onLoad(
                () => {
                    let ticking = setInterval(() => {
                        warning.set('display', 'none')
                        setTimeout(() => {
                            warning.set('display', '')
                        }, 200)
                    }, 400)
                    setTimeout(() => {
                        //just in case the lander doesnt emit
                        clearInterval(ticking)
                        warning.remove();
                    }, Math.abs(player.x - x) < width / 4 ? 13000 : 5000)
                    setTimeout(() => {
                        let sprite = new Img(imagePath, 0, 0,
                                width * ZOOM_SCALE / 3).fromCenter()
                            .usingNewTransform().onLoad(() => {
                                if (checkObj(monsters[index])) {
                                    monsters[index].loadingBar.circle.remove()
                                    monsters[index].loadingBar.remove();
                                }
                                sprite.zIndex = 5000;
                                monster = new Character(x, -height * 2, name);
                                LOADED_IMAGES.add(power + '_projectile');
                                monster.powerType = power;
                                monster.hasNoSkyBox = true;
                                monster.addSprite(sprite);
                                monster.jumpMult = 20 * width / 960;
                                monster.isCurrentlyJumping = true;
                                monster.addForce(VECTORS.gravity);
                                if (monster.height > height * 0.8) monster.width *= (height * 0.8) / monster.height;
                                monster.maxbounds.y = (height * 1.1) / 2 + monster.height / 2;
                                monster.addDeathImage(LOADED_IMAGES.fire.cloneNode());
                                let shield_name = 'shield_' + getRandom(valid_colors)
                                LOADED_IMAGES.add([shield_name], IMAGE_PATH + '/projectiles/');
                                monster.addShieldImage(LOADED_IMAGES[shield_name].cloneNode())
                                monster.projectileOffsetHeight = -height / 43;
                                monsterHP = createHPBar(sprite.shape, width / 1.8 + index * width / 20,
                                    height * 0.01 + index * height * 0.1, false, false)
                                monsterHP.zIndex = 10 + index * 2
                                monsterHP.circle.zIndex = 11 + index * 2
                                monsterHP.set('display', 'none')
                                monsterHP.circle.set('display', 'none')
                                let unsub = monster.landing_emitter.subscribe('land', () => {
                                    monsterHP.set('display', '')
                                    monsterHP.circle.set('display', '')
                                    warning.remove();
                                    clearInterval(ticking);
                                    if (Math.abs(monster.x - player.x) < width / 4) {
                                        player.height = 25;
                                        player.health -= 10;
                                        playerHP.value = player.health;
                                        if (player.x < width / 2) {
                                            player.faceRight();
                                            player.doJump(2)
                                        } else {
                                            player.faceLeft();
                                            player.doJump(2)
                                        }
                                        setTimeout(() => {
                                            player.height = '';
                                            if (player.x < width / 2) {
                                                player.faceRight();
                                            } else {
                                                player.faceLeft();
                                            }
                                        }, 3000)
                                    }
                                    unsub()
                                })

                                if (facingLeft) {
                                    monster.faceLeft();
                                    monster.landing_emitter.subscribe('land', () => {
                                        monster.faceLeft();
                                    });
                                } else {
                                    monster.faceRight();
                                    monster.landing_emitter.subscribe('land', () => {
                                        monster.faceRight();
                                    });

                                }
                                monster.iconReplaced = false;
                                currentlySpawning = false;
                                monsters[index] = {
                                    character: monster,
                                    loadingBar: monsterHP
                                }
                            });
                    }, Math.abs(player.x - x) < width / 4 ? 7000 : 3000)
                });
        }


        //arbitrary limit, 5 monsters max
        // once they are spawned they can be replaced
        function spawnNewMonster(index, xPos, facingLeft, isQuick) {
            if (index > 4) {
                console.error('max 5 monsters can be spawned')
                return;
            }
            currentlySpawning = true;
            let monsterHP = {};
            let monster = {}
            monster_char = create_monster();
            let time = isQuick ? 500 : 2500;
            if (checkObj(monsters[index]) && monsters[index].character.dead) {
                //if the last monster is dead but still exists use his health bar to get a new one
                monsterHP = monsters[index].loadingBar;
                monster = monsters[index].character;
                monsterHP.value = 0;
                setTimeout(() => {
                    monsterHP.circle.attachments.imgs[0].remove();
                    monsterHP.circle.detach(monsterHP.circle.attachments.imgs[0])
                    let skull = new Img(LOADED_IMAGES.skull_open, 0, 0, width / 13).onLoad(x => {
                        monsterHP.circle.attach(skull);
                    })
                }, time)
                setTimeout(() => {
                    let interval = setInterval(() => {
                        monsterHP.value += isQuick ? 4 : 1;
                        if (monsterHP.value >= 100) clearInterval(interval)
                    }, 20);
                }, time);
                setTimeout(() => {
                    createFallingMonster(xPos, monster_char.name, monster_char.power, IMAGE_PATH +
                        MONSTER_CONFIG.path + monster_char.name + '.png', index, facingLeft);
                }, time * 1.5)
            } else {
                createFallingMonster(xPos, monster_char.name, monster_char.power, IMAGE_PATH + MONSTER_CONFIG.path +
                    monster_char.name + '.png', index, facingLeft);
            }

        }


        let hopstop = false;
        let MONSTER_IS_CURRENTLY_SHOOTING = false;
        let MONSTER_RAPID_FIRE = false;
        let ALL_MONSTERS_ARE_DEAD = false
        let SUPER_HARDMODE_MODE = 'inactive'
        let validSuperHardmodeModes = ['twomonsters', 'angryfast', 'deadgiant', 'fourtiny', 'splitter'];



        function monsterShoot(index) {
            index = index || 0;
            if (!monsters[index].character.dead) {
                let atk = monsters[index].character.shoot();
                if (atk) {
                    atk.owner = 'monster';
                    projectiles.push(atk)
                }
            }
        }
        let PLAYERJUMP = false;
        let currentTime = window.performance.now()

        function startSuperHardMode() {
            SUPER_HARDMODE_MODE = getRandom(['angrygiant', 'twomonsters'])
            switch (SUPER_HARDMODE_MODE) {
                case 'twomonsters':
                    let newIndex = monsters[1] ? 0 : 1;
                    zoomEverything(-3)
                    monsters[!newIndex + 0].character.health = 50;
                    monsters[!newIndex + 0].loadingBar.value = 50;
                    let spawnOnLeftSide = monsters[!newIndex + 0].character.x >= width / 2;
                    monsters[!newIndex + 0].character.x = spawnOnLeftSide ? width * 0.9 : width * 0.1;
                    spawnNewMonster(newIndex, spawnOnLeftSide ? width * 0.1 : width * 0.9, !spawnOnLeftSide,
                        false);
                    break;
                case 'angrygiant':
                    monsters[0].character.health = 10;
                    monsters[0].loadingBar.value = 10;
                    monsters[0].character.maxbounds.x = width * 2
                    let zoom = 0;

                    function heal() {
                        monsters[0].character.health += 1;
                        monsters[0].character.x += monsters[0].character.x >= width / 2 ? 1 : -1;
                        monsters[0].loadingBar.value += 1;

                        zoom++
                        if (zoom > 10) zoomMonsters(r(zoom / 5))
                        if (monsters[0].character.health >= 100) {
                            monsters[0].character.health = 100
                            monsters[0].loadingBar.value = 100;
                            monsters[0].character.scale = 2
                        } else {
                            setTimeout(() => {
                                requestAnimationFrame(heal);
                            }, 20)
                        }
                    }
                    heal()
                    break;
            }
            SUPER_HARDMODE = false;
            HARDMODE_HAS_BEEN_ENABLED = false;
        }

        function loop(time) {
            let deltaT = time - currentTime;
            currentTime = time;
            player.update(deltaT);

            projectiles.forEach(projectile => {
                projectile.v.y = 0;
                projectile.update();
            });

            if (PLAYING && !PLAYERJUMP && !player.isCurrentlyJumping && !monsters.isAllDead) {
                player.sparHop(.5);
                PLAYERJUMP = true;
                setTimeout(() => PLAYERJUMP = false, 1500)
            }
            monsters.forEach((monsterObj, index) => {
                if (!checkObj(monsterObj.character)) return;
                let monster = monsterObj.character;
                let monsterHP = monsterObj.loadingBar;
                if (monster.dead) {
                    if (monster.dead && !monster.iconReplaced) {
                        monster.iconReplaced = true;
                        monsterHP.circle.attachments.imgs[0].remove();
                        monsterHP.circle.detach(monsterHP.circle.attachments.imgs[0])
                        let skull = new Img(LOADED_IMAGES.skull.cloneNode(), 0, 0, width / 13).onLoad(x => {
                            monsterHP.circle.attach(skull);
                        })
                    }

                    if (monster.dead && HARDMODE && !currentlySpawning) {
                        let spawnOnLeftSide = !getRandom(4)
                        if (monsters.length > 1) {
                            spawnOnLeftSide = monsters[!index + 0].character.x > width / 2;
                        }
                        let offset = SUPER_HARDMODE_MODE === 'inactive' ? 0.2 : 0.1
                        spawnNewMonster(index, spawnOnLeftSide ? width * offset : width * (1 - offset), !spawnOnLeftSide,
                            false);
                        HARDMODE = false;
                        player.health += 20
                        if (player.health >= 100) player.health = 100;
                        playerHP.value = player.health
                        if (HARDMODE_HAS_BEEN_ENABLED) {
                            //hardmode was beaten
                            SUPER_HARDMODE = true;
                        }
                        HARDMODE_HAS_BEEN_ENABLED = true;
                        if (PLAYING) id('play_PauseText').innerText = 'playing';
                    }
                    return
                }
                if (SUPER_HARDMODE) {
                    if (!monster.dead && monster.health <= 50 && !currentlySpawning) {

                        player.health += 40
                        if (player.health >= 100) player.health = 100;
                        playerHP.value = player.health
                        startSuperHardMode();
                    }
                }
                monster.update(deltaT);
                //projectiles hit calcs
                projectiles.forEach(projectile => {
                    //maybe needs to be redone for performance
                    if (projectile.owner === 'player') {
                        if (projectile.hitbox.contains(monster.hitbox.vMiddle)) {
                            if (!monster.isShielded) {
                                monster.health -= projectile.power;
                                if (projectile.power > 40) {
                                    shakeScreen();
                                }
                                //console.log(monster.health)
                                monsterHP.value = monster.health <= 0 ? 0 : monster.health | 0;
                                monster.doJump(-0.5 + projectile.power / 1000);
                            }
                            projectile.owner = '';
                            projectile.kill()
                        }
                        if (projectile.p.x > width) projectile.kill();
                    }
                    if (projectile.owner === 'monster') {
                        if (projectile.hitbox.contains(player.hitbox.vMiddle)) {
                            if (!player.isShielded) {
                                if (projectile.power > 40) {
                                    shakeScreen();
                                }
                                player.health -= projectile.power;
                                playerHP.value = player.health;
                            }
                            projectile.owner = '';
                            projectile.kill()
                        }
                        if (projectile.p.x < 0) projectile.kill();
                    }
                });


                //monster's movements
                if (PLAYING && !player.dead) {
                    if (Math.random() * 1000 < (HARDMODE ? 30 : 10)) {
                        if (!MONSTER_IS_CURRENTLY_SHOOTING && !monster.isCurrentlyJumping) {
                            monster.powerUp(SUPER_HARDMODE_MODE === 'inactive' ? 2 : 4);
                        }
                    }
                    if (getRandom(10000) < (HARDMODE ? 2 : 1)) {
                        monster.shield(getRandom(1, 4));
                    }
                    if (Math.random() * 1000 < (HARDMODE ? 2 : 1)) {
                        if (monster.isPoweringUp) {
                            monsterShoot(index);
                        }
                    }
                    if (Math.random() * 2000 < (HARDMODE ? (monster.health > 30 ? 30 : 10) : (monster.health >
                            30 ? 20 :
                            5))) {
                        monster.hop();
                    }
                    if (Math.random() * 3000 < 2) {
                        monster.jumpUp(15);
                    }
                    if (Math.random() * 10000 < (HARDMODE ? 3 : 2)) {
                        MONSTER_RAPID_FIRE = true;
                        console.log('rapid fire!')
                    }
                    if (monster.health > 80 && Math.random() * 1000 < 5 && !hopstop) {
                        monster.sparHop(.5).then(() => {
                            hopstop = false
                        });
                        hopstop = true;
                    }
                    if (MONSTER_RAPID_FIRE && !MONSTER_IS_CURRENTLY_SHOOTING) {
                        monster.powerUp(1);
                        MONSTER_IS_CURRENTLY_SHOOTING = true;
                        setTimeout(() => {
                            monsterShoot(index);
                            MONSTER_IS_CURRENTLY_SHOOTING = false;
                        }, 700);
                        if (Math.random() < 0.2) {
                            monster.jumpUp(5);
                        }
                        if (Math.random() < 0.1) {
                            MONSTER_RAPID_FIRE = false;
                        }


                    }
                } else if (PLAYING && player.dead) {
                    if (monster.isPoweringUp) {
                        monsterShoot(index);
                    }
                    if (Math.random() * 100 < 2) {
                        monster.jumpUp(10);
                    }
                }




            })
            if (LOOPING && FPSLOCK == 0) {
                requestAnimationFrame(loop)
            }
        }

        function start() {
            requestAnimationFrame(loop)
        };
        let FPSLOCK = 0;
        let FPSLOOP = 0;

        function setFPS(num) {
            stop()
            clearInterval(FPSLOOP)
            FPSLOCK = num;
            if (FPSLOCK > 0) {
                FPSLOOP = setInterval(() => loop(window.performance.now()), 1000 / FPSLOCK)
            } else {
                requestAnimationFrame(loop);
            }
        }


        LOOPING = true;
        setupBody(id("MAIN_SCREEN")).then(() => {
            setupBackground().then(() => {
                choose_your_fighter();
            })
        })

    </script>
</body>

</html>
